# A星寻路学习的一些小总结

## 基础原理
A星寻路的原理其实还是挺简单的，我个人总结就是以下几点：

* __代价：__ 这是A星寻路的核心思路，我们要找的合理的路线或最优路线，都要基于代价。
  寻找最小代价，可以说是最主要的方向。

* __n：__ 我们在去往终点上可能要经过的点。
  > __注意：__ 这里的点，是我们自己定义的网格中的单元点。

* __G(n)：__ 从开始点到当前单元点的实际使用的代价。
  > __注意：__ *实际使用的代价* 这里一般指的是累计使用的距离。

* __H(n)：__ 一般指的是从当前点到终点的代价。
  > __注意：__ 当指定为当前点到终点的代价时，一般用两点直接距离。</br>
  > __注意2：__ 当在使用寻找最优线路时，会用到遍历所有可能点。这时`H(n)`的意义更多的是在方向优先级。

* __F(n)：__ 我们自己拟定的一个当前点总代价的算法，一般是 `F(n) = G(n) + H(n)`
  > __注意：__ 这个总代价是可以根据不同情况进行制定义调整的。

* __可用列表：__ 这个列表存储着所有需要判断代价点，并且这个列表要保持`F(n)`的升序排列。
  > __注意：__ 可用列表是可已有最优方案的，.net 可以用SortedList,还用二叉堆。

* __关闭列表：__ 这个列表存储着所有死路点。
  > __注意：__ *死路点* 周围都不能走或周围的点在 *可用列表* 中

以上都是一些我要理解的一些要点的解释。

## 编写思路

1. 构建我们需要的网格，设置好起始点和终点并转换出向对应的网格点。

2. 将开始点的网格点存放到 __可用列表__ 。

3. 从 __可用列表__ 中取出第一个点，以这个网格点为中心点，遍历其9个相邻点。

4. 过滤出可走的、不在 __可用列表__ 并且不在 __关闭列表__ 的相邻点，如果过滤不出点，那将中心点从 __可用列表__ 移除并且加入 __关闭列表__ 。

5. 算出`F(n)`、设置其父点为中心点，再从过滤点中取出`F(n)`最小的几个点加入 __可用列表__ 中。

6. 以升序重排 __可用列表__。

7. 循环3，直到取出的点是终点时跳出。

8. 从终点向上取出父点直到父点为空，将这些父点集合倒序一下，就是最优路线。

## 问题总结

* 问题 ： 
  * __可用列表__ 里的点会出现多次遍历的可能。
  * __可用列表__ 的重排效率低。
* 优化 ：
  * H(n) 只取当前点到中心点的距离。 
  * __可用列表__ 里每次取出第一后就将其移除，并放进 __关闭列表__
  * __可用列表__ 使用 SortedList 或 自己实现最小二叉堆

可以说几乎所有的寻路算都是通过A\*算发改出来的，对于基础的A\*我们只要知道其实现方式和基础思想就好。</br>
在现实可能用到的地方，大多都有相关的现成封装和更好的实现。